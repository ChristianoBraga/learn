course on "Linguagens Formais"
	teaches < 'sec2_1 >, < 'sec2_2 >, < 'sec2_4 >, < 'int3 >, < 'sec3_1 >, < 'sec3_2 >, < 'sec3_3 >, < 'fig3_2 >, < 'sec3_7 >, < 'ex3_1 > and < 'ex3_2 >
with
	teaching strategy < 'class >
		< 'int3 > before < 'sec3_1 >,
		< 'sec3_1 > before < 'sec3_2 >,
		< 'sec3_2 > before < 'fig3_2 >,
		< 'fig3_2 > before < 'sec2_1 >,
		< 'sec2_1 > before < 'sec2_2 >,
		< 'sec2_2 > before < 'sec3_3 >,
		< 'sec3_3 > before < 'sec2_4 >,
		< 'sec2_4 > before < 'sec3_7 >,
		< 'sec3_7 > before < 'ex3_1 >,
		< 'ex3_1 > before < 'ex3_2 >
	teaching strategy < 'book >
		< 'sec2_1 > before < 'sec2_2 >,
		< 'sec2_2 > before < 'sec2_4 >,
		< 'sec2_4 > before < 'int3 >,
		< 'int3 > before < 'sec3_1 >,
		< 'sec3_1 > before < 'sec3_2 >,
		< 'sec3_2 > before < 'sec3_3 >,
		< 'sec3_3 > before < 'fig3_2 >,
		< 'fig3_2 > before < 'sec3_7 >,
		< 'sec3_7 > before < 'ex3_1 >,
		< 'ex3_1 > before < 'ex3_2 >

learning object < 'int3 > has
	title "Introducao ao Capitulo 3"
	image "auto.png"
	text "O estudo das linguagens regulares, ou tipo 3, e abordado usando os seguintes formalismos<br>a) Automato finito. Trata-se de um formalismo operacional ou reconhecedor, sendo, basicamente, um sistema de estados finitos;<br>b) Expressao regular. Trata-se de um formalismo denotacional, tambem considerado gerador (pois se pode inferir como construir todas as palavras da correspondente linguagem), o qual e definido a partir de conjuntos (linguagens) basicos e das operacoes de concatenacao e de uniao;<br>c) Gramatica regular. Trata-se de um formalismo axiomatico ou gerador o qual, como o nome indica, e uma gramatica, mas com restricoes da forma das regras de producao.<br><br>De acordo com a hierarquia de Chomsky, as linguagens regulares constituem a classe de linguagens mais simples, sendo possivel desenvolver algoritmos de reconhecimento, de geracao ou de conversao entre formalismos de pouca complexidade, de pouca eficiencia e de facil implementacao.<br>Entretanto, as linguagens regulares possuem fortes limitacoes de expressividade. Por exemplo, uma linguagem que possua duplo balanceamento nao e uma linguagem regular. Como exemplo, considere um texto com parenteses balanceados, ou seja, parenteses em um numero qualquer em um texto, eventualmente encadeados (aninhados), de tal forma a garantir que, para cada parentese aberto, existe um correspondente parentese fechado (e vice-versa).<br>Portanto, o tratamento de expressoes aritmeticas comuns nao pode ser realizado usando um formalismo regular. Assim, a maioria das linguagens de programacao de propositos gerais como Pascal, C, Java, etc., nao sao regulares.<br>Por outro lado, relativamente a complexidade de algoritmos , automatos finitos pertencem a classe de algoritmos mais eficientes em termos de tempo de processamento (supondo determinada condicao detalhada adiante). De fato, qualquer automato finito que solucione um problema e igualmente eficiente, ou seja, qualquer solucao e otima, a menos de eventual redundancia de estados, a qual nao influi no tempo de processamento. Tal redundancia de estados pode ser facilmente eliminada, determinando-se um automato finito minimo.<br>Outra caracteristica da classe das linguagens regulares e possuir importantes propriedades as quais podem ser usadas para:<br> \* construir novas linguagens regulares a partir de linguagens regulares conhecidas (definindo uma algebra);<br> \* provar propriedades;<br> \* construir algoritmos.<br>Considerando a eficiencia e a simplicidade dos algoritmos, bem como das propriedades da classe de linguagens regulares, deve ficar bem claro que, se um problema tiver uma solucao regular, esta deve ser considerada preferencialmente a qualquer outra solucao nao regular.<br>Um exemplo tipico e simples de aplicacao das linguagens regulares e a analise lexica. Observe que o universo de aplicacoes das linguagens regulares e muito grande e e constantemente ampliado por novas utilizacoes. Alguns exemplos mais recentes sao sistemas de animacao, hipertextos e hipermidias.<br>Minimizacao de automatos finitos, propriedades da classe das linguagens regulares e algumas importantes aplicacoes sao estudadas em capitulos subsequentes.<br>Para facilitar o estudo das linguagens regulares, a seguir sao apresentadas algumas nocoes de sistema de estados finitos e de composicao de sistemas."

learning object < 'sec2_1 > has
	title "Secao 2.1"
	text "ALFABETO<br><br>As definicoes que seguem sao construidas usando como base a nocao de simbolo ou caractere. Portanto, esta e uma entidade abstrata basica, nao sendo definida formalmente. Letras e digitos sao exemplos de simbolos frequentemente usados.<br><br>definicao 2.1 - alfabeto<br>Um alfabeto e um conjunto finito de simbolos ou caracteres.<br>Portanto:<br> \* um conjunto inifinito nao e um alfabeto<br> \* o conjunto vazio e um alfabeto<br><br>(...)"

learning object < 'sec2_2 > has
	title "Secao 2.2"
	text "PALAVRA<br><br>definicao 2.2 - Palavra, cadeia de caracteres, sentenca<br>Uma palavra, cadeira de caracteres ou sentenca sobre um alfabeto e uma sequencia finita de simbolos (do alfabeto) justapostos.<br>Portanto, uma cadeia sem simbolos e uma palavra valida, e o simbolo &epsilon; denota a cadeia vazia ou palavra vazia<br><br>definicao 2.3 - Prefixo, sufixo, subpalavra<br>Um prefixo (respectivamente, sufixo) de uma palavra e qualquer sequencia inicial (respectivamente, final) de simbolos da palavra.<br>Uma subpalavra de uma palavra e qualquer sequencia de simbolos contiguos da palavra.<br><br>(...)<br><br>definicao 2.4 - Concatenacao de palavras<br>A concatenacao de palavras ou simplesmente concatenacao e uma operacao binaria, definida sobre um conjunto de palavras, a qual associa a cada par de palavras uma palavra formada pela justaposicao da primeira com a segunda.<br>Uma concatenacao e denotada pela justaposicao dos simbolos que representam as palavras componentes. A operacao de concatenacao satisfaz as seguintes propriedades (suponha v, w, t palavras quaisquer):<br>a) Associativa. v(w t) = (v w)t<br>b) Elemento neutro.<br>&epsilon; w = w = w &epsilon;<br>Como a concatenacao de palavras e uma operacao associativa, e usual omitir os parenteses. Assim, v(w t) ou (v w)t pode ser denotado simplesmente por v w t.<br><br>(...)<br><br>definicao 2.5 - Concatenacao sucessiva de uma palavra (com ela mesma) ou simplesmente concatenacao sucessiva representada na forma de um expoente (suponha w uma palavra):<br>w^n, onde n e o numero de concatenacoes sucessivas<br>e definida indutivamente a partir da operacao de concatenacao binaria, como segue:<br>w^0 = &epsilon;<br>w^n = w w^(n-1), para n > 0<br><br>(...)<br><br>definicao 2.6 - Conjunto de todas as palavras<br>Seja &Sigma; um alfabeto. Entao o conjunto de todas as palavras &Sigma;\* e indutivamente definido como segue:<br>a) Base de inducao.<br>&epsilon; &isin; &Sigma;\*, para qualquer x &isin; &Sigma;, vale x &isin; &Sigma;\*<br>b) Passo de inducao.<br>Se u e v sao palavras de &Sigma;\*, entao a concatenacao u v e uma palavra de &Sigma;\*<br>Portanto, uma definicao alternativa para palavra, cadeira de caracteres ou sentenca sobre um alfabeto &Sigma; e qualquer lemento w de &Sigma;\*, ou seja:<br>w &isin; &Sigma;\*<br><br>(...)<br><br>definicao 2.7 - Comprimento, tamanho de uma palavra<br>O comprimento ou tamanho de uma palavra w, representado por |w|, e o numero de simbolos que compoem a palavra. Portanto, para um dado alfabeto &Sigma;, comprimento e uma funcao com dominio em &Sigma;\* e codominio em N.<br><br>(...)"

learning object < 'sec2_4 > has
	title "Secao 2.4"
	text "GRAMATICA<br><br>Ja foi dito que uma linguagem de programacao e formalmente definida pelo conjunto de todos os programas (palavras) da linguagem. Como, em geral, o conjunto de todos os programas de uma linguagem de propositos gerais como Pascal e infinito, nao e uma definicao adequada para ser implementada em um computador. Uma maneira de especificar de forma finita linguagens (eventualmente) infinitas e usando o formalismo gramatica.<br>Uma gramatica e, basicamente, um conjunto finito de regras as quais, quando aplicadas sucessivamente, geram palavras. O conjunto de todas as palavras geradas por uma gramatica define a linguagem. As gramaticas usadas para as linguagens naturais como porgues, sao as mesmas que as usadas para linguagens artificiais como Pascal. Eventualmente, gramaticas tambem sao usadas para definir semantica de linguagens. Entretanto, para tratar semantica, em geral, sao usados outros formalismos.<br><br>definicao 2.9 - Gramatica<br>Uma gramatica de Chomsky, gramatica irrestrita ou simplesmente gramatica e uma quadrupla ordenada:<br>G = (V, T, P, S)<br>na qual:<br>a) V, um conjunto finito de simbolos variaveis ou nao terminais;<br>b)T, um conjunto finito de simbolos terminais disjunto de V;<br>c) P: (V &cup; T)+ -> (V &cup; T)\* e uma relacao finita (ou seja, P e um conjunto finito de pares), denominada de relacao de producoes ou simplesmente producoes. Cada par da relacao e denominado de regra de producao ou simplesmente de producao;<br>d) S, um elemento distinguido de V denominado simbolo inicial ou variavel inicial.<br><br>Uma regra de producao (&alpha;, &beta;) e representada como segue:<br>&alpha; -> &beta;<br>Por simplicidade, um grupo de regras de producao da forma:<br>&alpha; -> &beta;1 | &beta;2 | ... | &beta;n<br>As regras de producao definem as condicoes de geracao das palavras da linguagem. A aplicacao de uma regra de producao e denominada derivacao de uma palavra e e formalmente definida como um par de uma relacao. A aplicacao sucessiva de regras de producao (fecho transitivo da relacao de derivacao) permite derivar as palavras da linguagem representada pela gramatica.<br><br>definicao 2.10 - Relacao de derivacao<br>Seja G = (V, T, P, S) uma gramativa. Uma derivacao e um par da relacao de derivacao denotada por &rArr; com dominio em (V &cup; T)+ e codominio em (V &cup; T)\*. Um par <&alpha;, &beta;> da relacao de derivacao e representado de forma infixada como segue:<br>&alpha; &rArr; &beta;<br>A relacao de derivacao &rArr; e indutivamente definida como segue:<br>a) Para toda producao da forma S -> &beta; (S e o simbolo inicial de G), o seguinte par pertence a relacao de derivacao:<br>S &rArr; &beta;<br>b) Para todo par &eta; &rArr; &rho; &alpha; &sigma; da relacao de derivacao, se &alpha; -> &beta; e regra de P, entao o seguinte par tambem pertence a relacao de derivacao:<br>&eta; &rArr; &rho; &beta; &sigma;<br>Portanto, uma derivacao e a substituicao de uma subpalavra de acordo com uma regra de producao.<br>Sucessivos passos de derivacao sao definidos como segue:<br>&rArr;\* fecho transitivo e reflexivo da relacao &rArr;, ou seja, zero ou mais passos de derivacoes sucessivos;<br>&rArr;+ fecho transitivo da relacao &rArr;, ou seja, um ou mais passos de derivacoes sucessivos;<br>&rArr;i exatos i passos de derivacoes sucessivos, sendo i um numero natural.<br><br>Gramaticas sao consideradas formalismos de geracao, pois permitem derivar (\"gerar\") todas as palavras da linguagem que representam.<br><br>definicao 2.11 - Linguagem gerada<br>Seja G = (V, T, P, S) uma gramatica. A linguagem gerada pela gramatica G, denotada por L(G) ou GERA(G), e composta por todas as palavras de simbolos terminais derivaveis a partir do simbolo inicial S, ou seja:<br>L(G) = {w &isin; T\* | S &rArr;+ w}<br><br>(...)<br><br>definicao 2.12 - Gramaticas equivalentes<br>Duas gramaticas G1 e G2 sao ditas gramaticas equivalentes se e somente:<br>GERA(G1) = GERA(G2)<br><br>(...)"

learning object < 'sec3_1 > has
	title "Secao 3.1"
	text "SISTEMA DE ESTADOS FINITOS<br><br>Um sistema de estados finitos e um modelo matematico de sistema com entradas e saidas discretas (em oposicao ao continuo). Pode assumir um numero finito e predefinido de estados. Cada estado resume somente as informacoes do passado necessarias para determinar as acoes para a proxima entrada. O fato de possuir um numero finito e predefinido de estados significa que todos os estados possiveis do sistema podem ser mecanicamente explicitados antes de iniciar o processamento, ou seja, podem ser definidos de partida, por extensao.<br>Um forte motivacional para o estudo de sistemas de estados finitos e o fato de poderem ser associados a diversos tipos de sistemas naturais e construidos.<br>Um exemplo classico e de simples entendimento e um elevador. Trata-se de um sistema que nao memoriza as requisicoes anteriores. Cada \"estado\" sumaria as informacoes \"andar corrente\" e \"direcao de movimento\". As entradas para o sistema sao requisicoes pendentes.<br>Analisadores lexicos e processadores de texto (ou algumas ferramentas de processadores de texto) tambem sao exemplos de sistemas de estados finitos, dos quais cada estado, basicamente, memoriza a estrutura do prefixo da palavra em analise.<br>Entretanto, nem todos os sistemas de estados finitos sao adequados para serem estudados por esta abordagem. Um contraexemplo e o cerebro humano. Existem evidencias de que um neuronio pode ser representado por um numero finito de bits. O cerebro e composto por cerca de 2^35 celulas. Portanto, a principio, e possivel representa-lo por um numero finito de estados. Entretanto, o elevado numero de combinacoes de celulas (e, consequentemente, de estados) determina uma abordagem pouco eficiente em termos praticos. Tal fenomeno e denominado explosao de estados.<br>Outro contraexemplo e o computador. Os estados determinados pelos processadores e memorias podem ser representados como um sistema de estados finitos. Entretanto, em um computador, podem ser agregadas memorias adicionais durante o processamento (discos, fitas, memorias auxiliares, etc.). Assim, o numero de estados nao necessariamente e predefinido antes de se iniciar uma computacao, quebrando um dos principios dos automatos finitos. De fato, o estudo adequado da nocao de computabilidade exige uma memoria sem limite predefinido. Adiante, e apresentado um outro formalismo de automato, a maquina de Turing, com tais caracteristicas e portanto, adequado ao estudo da computabilidade. Note-se que o estudo da computabilidade e solucionabilidade de problemas e apenas introduzido nesta publicacao (usualmente tais questoes sao tratadas na teoria da computacao)."

learning object < 'sec3_2 > has
	title "Secao 3.2"
	text "COMPOSICAO SEQUENCIAL, CONCORRENTE E NAO DETERMINISTA<br><br>A construcao de um sistema e, em geral, composicional, no sentido em que sistemas (possivelmente complexos) sao construidos a partir de sistemas conhecidos, e assim sucessivamente, ate chegar ao nivel mais elementar (como uma acao atomica). Tres formas de composicao se destacam:<br>a) Sequencial. A execucao da proxima componente depende da terminacao da componente anterior;<br>b) Concorrente. Resulta em componentes independentes, no sentido em que a ordem em que sao executadas nao e importante, e, portanto, podem ser processadas ao mesmo tempo;<br>c) Nao Determinista. A proxima componente a ser executada e uma escolha entre diversas componentes alternativas (em oposicao a determinista, na qual, para as mesmas condiceos, a proxima componente a ser executada e sempre a mesma). O nao determinismo pode ser:<br> \* interno: o sistema escolhe aleatoriamente a proxima componente a ser executada;<br> \* externo: a escolha da proxima componente a ser executada e externa ao sistema.<br>As tres formas de composicao sao comuns nos sistemas reais. Por exemplo, considere-se um universo de pessoas em um banco, no qual as seguintes composicoes podem ocorrer, entre diversas outras possibilidades:<br> \* sequencial: em uma fila, o atendimento do proximo cliente depende do atendimento do cliente anterior; o pagamento de uma conta depende do fornecimento de um valor;<br> \* concorrente: os diversos caixas atendem independentemente diversos clientes;<br> \* nao determinista: quando dois ou mais caixas ficam disponiveis ao mesmo tempo, o proximo cliente pode escolher em qual caixa sera atendido; o simples caminhar de um individuo pode aleatoriamente iniciar com a perna esquerda ou com a perna direita.<br>Portanto, na modelagem de sistemas em geral, a tres formas de composicao devem ser consideradas.<br>No caso especifico das linguagens formais, as composicoes sequencial e nao determinista sao especialmente importantes, e e nestas que o estudo e centrado. Como curiosidade, detaca-se que a composicao concorrente pode ser simulada, usando-se as composicoes sequencial e nao determinista, e sendo, neste caso, denominada concorrencia falsa.<br>Em particular, a semantica do nao determinismo adotada em todo o texto que segue e a usual para linguagens formais, para teoria da computacao, bem como para os demais estudos correlatos, e pode ser resumida como segue:<br> \* considera o nao determinismo interno;<br> \* objetiva determinar a capacidade de reconhecer linguagens e de solucionar problemas. Assim, se pelo menos um caminho alternativo e capaz de reconhecer ou solucionar (mesmo que outros nao o sejam), a maquina como um todo e considerada capaz de reconhecer ou solucionar.<br>Esta semantica, detalhada ao longo do texto, difere, por exemplo, da usualmente adotada no estudo dos modelos para concorrencia (e consequentes aplicacoes como, por exemplo, no estudo dos sistemas operacionais), e pode causar alguma confusao com a semantica da concorrencia."

learning object < 'sec3_3 > has
	title "Secao 3.3"
	text "AUTOMATO FINITO<br><br>Automato finito e um sistema de estados finitos (portanto possui um numero finito e predefinido de estados) o qual constitui um modeli computacional do tipo sequencial muito comum em diversos estudos teorico-formais da computacao e informatica, com destaque para linguagens formais, compiladores, semantica formal e modelos para concorrencia.<br>Trata-se de um formalismo operacional ou reconhecedor, o qual pode ser:<br> \* deterministico: para o estado corrente e o simbolo lido da entrada, o sistema assume um unico estado bem determinado;<br> \* nao deterministo: para o estado corrente e o simbolo lido da entrada, o sistema assume um estado pertencente a um conjunto de estados alternativos;<br> \* com movimentos vazios: para o estado corrente e, independentemente de ler um simbolo ou nao da entrada, o sistema assume um estado pertencente a um conjunto de estados alternativos (portanto e nao deterministico). O movimento e dito movimento vazio se o sistema muda de estado sem uma correspondente leitura de simbolo. Movimentos vazios podem ser vistos como transicoes encapsuladas nas quais, excetuando-se por uma eventual mudança de estado, nada mais pode ser observado, de forma analoga a nocao de encapsulacao das linguagens orientadas a objetos.<br>Prova-se que os tres tipos de automatos acima sao equivalentes em termos de poder computacional.<br>Um automato finito deterministico ou simplesmente automato finito pode ser visto como uma maquina constituida, basicamente, de tres partes:<br>a) Fita. Dispositivo de entrada que contem a informacao a ser processada;<br>b) Unidade de controle. Reflete do estado corrente da maquina. Possui uma unidade de teitura (cabeca da fita) a qual acessa uma celula da fita de cada vez e movimenta-se exclusivamente para a direita;<br>c) Programa, funcao programa ou funcao de transicao. Funcao que comanda as leituras e define o estado da maquina.<br>A fita e finita(a esquerda e a direita), sendo dividida em celulas, cada uma das quais armazena um simbolo. Os simbolos pertencem a um alfabeto de entrada. Nao e possivel gravar sobre a fita (e nao existe memoria auxiliar). Inicialmente, a palavra a ser processada (ou seja, a informacao de entrada para a maquina) ocupa toda a fita.<br> A unidade de controle possui um numero finito e predefinido de estados, originando o termo controle finito. A unidade de controle le um simbolo da fita de cada vez. Apos a leitura, a cabeca da fita move-se uma celula para a direita. Inicialmete, a cabeca esta posicionada na celula mais a esquerda da fita, como ilustrado na figura 3.1.<br><br>(...)"
	image "figura_3.1.png"

learning object < 'sec3_7 > has
	title "Secao 3.7"
	text "GRAMATICA REGULAR<br><br>Usando o conceito de gramaticas como apresentado no capitulo 2 - Linguagens e gramaticas, e possivel definir tanto linguagens regulares como linguagens nao regulares. Entretanto, e possivel estabelecer restricoes nas regras de producao, de tal forma a definir exatamente a classe das linguagens regulares.<br>Existe mais de uma forma de restringir as regras de producao de forma a definir uma gramatica regular. A seguir, sao apresentadas quatro dessas formas, denominadas gramaticas lineares.<br><br>definicao 3.23 - Gramaticas lineares<br>Seja G = (V, T, P, S) uma gramatica. Sejam A e B elementos de V e w uma palavra de T\*. Entao G e uma gramatica linear se todas as suas producoes encontram-se em uma e em somente uma das seguintes formas:<br>a) Gramatica linear a direita (abreviada por GLD). Todas as regras de producao sao da forma:<br>A -> wB ou A -> w<br>b) Gramatica linear a esquerda (abreviada por GLE). Todas as regras de producao sao da forma:<br>A -> Bw ou A -> w<br>c) Gramatica linear unitaria a direita (abreviada por GLUD). Todas as regras de producao sao como na gramatica linear a direita e, adicionalmente:<br>|w| <= 1<br>d) Gramatica linear unitaria a esquerda (abreviada por GLUE). Todas as regras de producao sao como na gramatica linear a esquerda e, adicionalmente:<br>|w| <= 1<br><br>Note-se que as gramaticas lineares possuem forte restricao no formato de suas producoes:<br> \* o lado esquerdo possui exatamente uma variavel;<br> \* o lado direito de uma producao e constituido por, no maximo, uma variavel. Adicionalmente, esta variavel, se existir, sempre antecede (linear a esquerda) ou sucede (linear a direita) qualquer subpalavra (eventualmente vazia) de terminais.<br>Sugere-se como exercicio verificar se e possivel definir uma gramatica que satisfaca simultaneamente as quatro formas lineares.<br>(...)"

learning object < 'fig3_2 > has
	title "Figura 3.2"
	image "figura_3.2.png"
	text "Diagrama (AFD): transicao"

learning object < 'ex3_1 > has
	title "Exercicio 3.1"
	text "Sobre as linguagens regulares:<br>a) Qual a importancia do seu estudo?<br>b) Exemplifique suas aplicacoes (para os diversos formalismos);<br>c) Voce imagina algum tipo de linguagem cujo algoritmo de reconhecimento seja mais eficiente que o das regulares? E menos eficiente? Explique a sua resposta."

learning object < 'ex3_2 > has
	title "Exercicio 3.2"
	text "Desenvolva automatos finitos deterministicos que reconhecam as seguintes linguagens sobre Sigma = {a, b}:<br>a) {w tal que o sufixo de w e aa}<br>b) {w tal que w possui aaa como subpalavra}<br>c) {w tal que w possui numero impar de a e numero impar de b}<br>d) {w tal que w possui numero par de a e impar de b ou w possui numero par de b e impar de a}<br>e) {w tal que o quinto simbolo da direita para a esquerda de w e a}"
