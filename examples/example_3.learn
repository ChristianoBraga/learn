course on "Linguagens Formais"
	teaches < 'int3 >, < 'sec3_2 >, < 'sec3_1 >, < 'fig3_2 >, < 'ex3_1 > and < 'ex3_2 >
with
	exercises < 'ex3_1 > and < 'ex3_2 >
	teaching strategy < 'ex >
		exercises after all but the exercises

learning object < 'int3 > has
	title "Introducao ao Capitulo 3"
	image "auto.png"
	text "O estudo das linguagens regulares, ou tipo 3, e abordado usando os seguintes formalismos<br>a) Automato finito. Trata-se de um formalismo operacional ou reconhecedor, sendo, basicamente, um sistema de estados finitos;<br>b) Expressao regular. Trata-se de um formalismo denotacional, tambem considerado gerador (pois se pode inferir como construir todas as palavras da correspondente linguagem), o qual e definido a partir de conjuntos (linguagens) basicos e das operacoes de concatenacao e de uniao;<br>c) Gramatica regular. Trata-se de um formalismo axiomatico ou gerador o qual, como o nome indica, e uma gramatica, mas com restricoes da forma das regras de producao.<br><br>De acordo com a hierarquia de Chomsky, as linguagens regulares constituem a classe de linguagens mais simples, sendo possivel desenvolver algoritmos de reconhecimento, de geracao ou de conversao entre formalismos de pouca complexidade, de pouca eficiencia e de facil implementacao.<br>Entretanto, as linguagens regulares possuem fortes limitacoes de expressividade. Por exemplo, uma linguagem que possua duplo balanceamento nao e uma linguagem regular. Como exemplo, considere um texto com parenteses balanceados, ou seja, parenteses em um numero qualquer em um texto, eventualmente encadeados (aninhados), de tal forma a garantir que, para cada parentese aberto, existe um correspondente parentese fechado (e vice-versa).<br>Portanto, o tratamento de expressoes aritmeticas comuns nao pode ser realizado usando um formalismo regular. Assim, a maioria das linguagens de programacao de propositos gerais como Pascal, C, Java, etc., nao sao regulares.<br>Por outro lado, relativamente a complexidade de algoritmos , automatos finitos pertencem a classe de algoritmos mais eficientes em termos de tempo de processamento (supondo determinada condicao detalhada adiante). De fato, qualquer automato finito que solucione um problema e igualmente eficiente, ou seja, qualquer solucao e otima, a menos de eventual redundancia de estados, a qual nao influi no tempo de processamento. Tal redundancia de estados pode ser facilmente eliminada, determinando-se um automato finito minimo.<br>Outra caracteristica da classe das linguagens regulares e possuir importantes propriedades as quais podem ser usadas para:<br> \* construir novas linguagens regulares a partir de linguagens regulares conhecidas (definindo uma algebra);<br> \* provar propriedades;<br> \* construir algoritmos.<br>Considerando a eficiencia e a simplicidade dos algoritmos, bem como das propriedades da classe de linguagens regulares, deve ficar bem claro que, se um problema tiver uma solucao regular, esta deve ser considerada preferencialmente a qualquer outra solucao nao regular.<br>Um exemplo tipico e simples de aplicacao das linguagens regulares e a analise lexica. Observe que o universo de aplicacoes das linguagens regulares e muito grande e e constantemente ampliado por novas utilizacoes. Alguns exemplos mais recentes sao sistemas de animacao, hipertextos e hipermidias.<br>Minimizacao de automatos finitos, propriedades da classe das linguagens regulares e algumas importantes aplicacoes sao estudadas em capitulos subsequentes.<br>Para facilitar o estudo das linguagens regulares, a seguir sao apresentadas algumas nocoes de sistema de estados finitos e de composicao de sistemas."

learning object < 'sec3_2 > has
	title "Secao 3.2"
	text "COMPOSICAO SEQUENCIAL, CONCORRENTE E NAO DETERMINISTA<br><br>A construcao de um sistema e, em geral, composicional, no sentido em que sistemas (possivelmente complexos) sao construidos a partir de sistemas conhecidos, e assim sucessivamente, ate chegar ao nivel mais elementar (como uma acao atomica). Tres formas de composicao se destacam:<br>a) Sequencial. A execucao da proxima componente depende da terminacao da componente anterior;<br>b) Concorrente. Resulta em componentes independentes, no sentido em que a ordem em que sao executadas nao e importante, e, portanto, podem ser processadas ao mesmo tempo;<br>c) Nao Determinista. A proxima componente a ser executada e uma escolha entre diversas componentes alternativas (em oposicao a determinista, na qual, para as mesmas condiceos, a proxima componente a ser executada e sempre a mesma). O nao determinismo pode ser:<br> \* interno: o sistema escolhe aleatoriamente a proxima componente a ser executada;<br> \* externo: a escolha da proxima componente a ser executada e externa ao sistema.<br>As tres formas de composicao sao comuns nos sistemas reais. Por exemplo, considere-se um universo de pessoas em um banco, no qual as seguintes composicoes podem ocorrer, entre diversas outras possibilidades:<br> \* sequencial: em uma fila, o atendimento do proximo cliente depende do atendimento do cliente anterior; o pagamento de uma conta depende do fornecimento de um valor;<br> \* concorrente: os diversos caixas atendem independentemente diversos clientes;<br> \* nao determinista: quando dois ou mais caixas ficam disponiveis ao mesmo tempo, o proximo cliente pode escolher em qual caixa sera atendido; o simples caminhar de um individuo pode aleatoriamente iniciar com a perna esquerda ou com a perna direita.<br>Portanto, na modelagem de sistemas em geral, a tres formas de composicao devem ser consideradas.<br>No caso especifico das linguagens formais, as composicoes sequencial e nao determinista sao especialmente importantes, e e nestas que o estudo e centrado. Como curiosidade, detaca-se que a composicao concorrente pode ser simulada, usando-se as composicoes sequencial e nao determinista, e sendo, neste caso, denominada concorrencia falsa.<br>Em particular, a semantica do nao determinismo adotada em todo o texto que segue e a usual para linguagens formais, para teoria da computacao, bem como para os demais estudos correlatos, e pode ser resumida como segue:<br> \* considera o nao determinismo interno;<br> \* objetiva determinar a capacidade de reconhecer linguagens e de solucionar problemas. Assim, se pelo menos um caminho alternativo e capaz de reconhecer ou solucionar (mesmo que outros nao o sejam), a maquina como um todo e considerada capaz de reconhecer ou solucionar.<br>Esta semantica, detalhada ao longo do texto, difere, por exemplo, da usualmente adotada no estudo dos modelos para concorrencia (e consequentes aplicacoes como, por exemplo, no estudo dos sistemas operacionais), e pode causar alguma confusao com a semantica da concorrencia."

learning object < 'sec3_1 > has
	title "Secao 3.1"
	text "SISTEMA DE ESTADOS FINITOS<br><br>Um sistema de estados finitos e um modelo matematico de sistema com entradas e saidas discretas (em oposicao ao continuo). Pode assumir um numero finito e predefinido de estados. Cada estado resume somente as informacoes do passado necessarias para determinar as acoes para a proxima entrada. O fato de possuir um numero finito e predefinido de estados significa que todos os estados possiveis do sistema podem ser mecanicamente explicitados antes de iniciar o processamento, ou seja, podem ser definidos de partida, por extensao.<br>Um forte motivacional para o estudo de sistemas de estados finitos e o fato de poderem ser associados a diversos tipos de sistemas naturais e construidos.<br>Um exemplo classico e de simples entendimento e um elevador. Trata-se de um sistema que nao memoriza as requisicoes anteriores. Cada \"estado\" sumaria as informacoes \"andar corrente\" e \"direcao de movimento\". As entradas para o sistema sao requisicoes pendentes.<br>Analisadores lexicos e processadores de texto (ou algumas ferramentas de processadores de texto) tambem sao exemplos de sistemas de estados finitos, dos quais cada estado, basicamente, memoriza a estrutura do prefixo da palavra em analise.<br>Entretanto, nem todos os sistemas de estados finitos sao adequados para serem estudados por esta abordagem. Um contraexemplo e o cerebro humano. Existem evidencias de que um neuronio pode ser representado por um numero finito de bits. O cerebro e composto por cerca de 2^35 celulas. Portanto, a principio, e possivel representa-lo por um numero finito de estados. Entretanto, o elevado numero de combinacoes de celulas (e, consequentemente, de estados) determina uma abordagem pouco eficiente em termos praticos. Tal fenomeno e denominado explosao de estados.<br>Outro contraexemplo e o computador. Os estados determinados pelos processadores e memorias podem ser representados como um sistema de estados finitos. Entretanto, em um computador, podem ser agregadas memorias adicionais durante o processamento (discos, fitas, memorias auxiliares, etc.). Assim, o numero de estados nao necessariamente e predefinido antes de se iniciar uma computacao, quebrando um dos principios dos automatos finitos. De fato, o estudo adequado da nocao de computabilidade exige uma memoria sem limite predefinido. Adiante, e apresentado um outro formalismo de automato, a maquina de Turing, com tais caracteristicas e portanto, adequado ao estudo da computabilidade. Note-se que o estudo da computabilidade e solucionabilidade de problemas e apenas introduzido nesta publicacao (usualmente tais questoes sao tratadas na teoria da computacao)."

learning object < 'fig3_2 > has
	title "Figura 3.2"
	image "figura_3.2.png"
	text "Diagrama (AFD): transicao"

learning object < 'ex3_1 > has
	title "Exercicio 3.1"
	text "Sobre as linguagens regulares:<br>a) Qual a importancia do seu estudo?<br>b) Exemplifique suas aplicacoes (para os diversos formalismos);<br>c) Voce imagina algum tipo de linguagem cujo algoritmo de reconhecimento seja mais eficiente que o das regulares? E menos eficiente? Explique a sua resposta."

learning object < 'ex3_2 > has
	title "Exercicio 3.2"
	text "Desenvolva automatos finitos deterministicos que reconhecam as seguintes linguagens sobre Sigma = {a, b}:<br>a) {w tal que o sufixo de w e aa}<br>b) {w tal que w possui aaa como subpalavra}<br>c) {w tal que w possui numero impar de a e numero impar de b}<br>d) {w tal que w possui numero par de a e impar de b ou w possui numero par de b e impar de a}<br>e) {w tal que o quinto simbolo da direita para a esquerda de w e a}"
